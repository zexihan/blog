---
layout:     post
title:      "<>DS - Deque"
subtitle:   "DS Note"
date:       2016-11-22
author:     "Zexi"
header-img: "img/post-bg-js-module.jpg"
catalog: true
tags:
    - Algorithms
    - Data Structure
---



## Deque

http://blog.csdn.net/top_code/article/details/8650729

一个线性 collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。

此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。

下表总结了上述 12 种方法：

First-第一个元素（头部）, Last-最后一个元素（尾部）

|	   | 抛出异常       | 特殊值        | 抛出异常       | 特殊值         |
|:----:|:-------------:|:-------------:|:-------------:|:-------------:|
| 插入 | addFirst(e)   | offerFirst(e) | addLast(e)   |	offerLast(e) |
| 移除 | removeFirst() | pollFirst()   | removeLast() |	pollLast()   |
| 检查 | getFirst()	 | peekFirst()   | getLast()    |	peekLast()   |

此接口扩展了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：

| Queue 方法 | 等效 Deque 方法 |
|:----------:|:--------------:|
|  add(e)	 |   addLast(e)   |
|  offer(e)	 |   offerLast(e) |
|  remove()	 |  removeFirst() |
|   poll()	 |  pollFirst()   |
| element()	 |  getFirst()    |
|  peek()	 |  peekFirst()   |

双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于Deque 方法，如下表所示：

| Stack 方法 | 等效 Deque 方法 |
|:----------:|:--------------:|
|  push(e)   |   addFirst(e)  |
|  pop()     |  removeFirst() |
|  peek()    |  peekFirst()   |

注意，在将双端队列用作队列或堆栈时，peek 方法同样正常工作；无论哪种情况下，都从双端队列的开头抽取元素。

此接口提供了两种移除内部元素的方法：removeFirstOccurrence 和 removeLastOccurrence。

与 List 接口不同，此接口不支持通过索引访问元素。

虽然 Deque 实现没有严格要求禁止插入 null 元素，但建议最好这样做。建议任何事实上允许 null 元素的 Deque 实现用户最好不 要利用插入 null 的功能。这是因为各种方法会将null 用作特殊的返回值来指示双端队列为空。

Deque 实现通常不定义基于元素的 equals 和 hashCode 方法，而是从 Object 类继承基于身份的equals 和 hashCode 方法。 

```java
package com.yulore.ex;  
  
import java.util.ArrayDeque;  
import java.util.Deque;  
  
public class DequeTest {  
  
    /** 
     * @param args 
     */  
    public static void main(String[] args) {  
        Deque<Integer> mDeque = new ArrayDeque<Integer>();  
          
        for(int i=0;i<5;i++){  
            mDeque.offer(i);  
        }  
          
        System.out.println(mDeque.peek());  
          
        System.out.println("***********集合方式遍历**********");   
          
        //集合方式遍历，元素不会被移除   
        for (Integer x : mDeque) {   
                System.out.println(x);   
        }   
          
        System.out.println("**********遍历队列*************");   
          
        //队列方式遍历，元素逐个被移除   
        while (mDeque.peek() != null) {   
                System.out.println(mDeque.poll());   
        }   
          
        System.out.println("***********进栈操作************");   
          
        mDeque.push(10);  
        mDeque.push(15);  
        mDeque.push(24);  
        print(mDeque);  
          
        System.out.println("*********出栈操作*************");   
          
        System.out.println(mDeque.pop());  
    }  
      
    public static void print(Deque<Integer> queue){  
        //集合方式遍历，元素不会被移除   
        for (Integer x : queue) {   
                System.out.println(x);   
        }   
    }  
} 
``` 